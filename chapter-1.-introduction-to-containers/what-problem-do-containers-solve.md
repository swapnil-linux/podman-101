# What problem do containers solve?

To best understand what a **software container** is, one should first know why they are useful. As Solomon Hykes, co-founder of Docker, explained in 2013, the concept comes from shipping containers: boxes with a standard shape, size, and locking mechanism used to ship goods around the world. Any shipping container can be moved around by the same cranes, ships, trains, and trucks because these only interact with the box itself, regardless of its contents. **This separation of concerns allows for automation, which leads to higher reliability and lowers costs.**

![](<../.gitbook/assets/image (4).png>)

The software industry has a myriad of **boxes into which to put code**. Boxes like Debian software packages (.deb files) or Java Archives (.jar archives) allow developers to **package their applications so that they can easily be copied to and run on different machines**. But these boxes have limitations: Java Archives can only hold Java code, and Debian packages only work on the Debian family of Linux distributions. **Modern applications rely on a variety of programming languages and operating systems**: the industry needs a box that is multilingual and multi-platform.

When putting code inside a box and shipping it to various computers, the **main concern is that the code should behave in the same way on each platform**, be it a developer's laptop, a staging server, or the public cloud. In practice, this is difficult because a software component's dependencies can reach far beyond its code. For example, a Django web application needs the Python code interpreter to run, but may also rely on system libraries, which can be different depending on the operating system. **The code must be packaged with its entire environment to run reliably everywhere**. In other words, every single dependency must fit into the application's box.

This idea is not new to the software industry. For many years now, **operators have used virtual machines as this kind of box**. Everything fits inside a VM: the code, its dependencies, and even the operating system. The critical insight here is to ship the application alongside the entire system. A developer's choice of distribution affects the behaviour of their application, and swapping out these system libraries would change the behaviour of the software. The system is part of any application a developer writes.

**The issue with virtual machines is that they also contain virtual hardware**. A developer should not decide how storage or networking is going to work, or what kind of processor to use. Such overreach would hinder the infrastructure provider's freedom to make hardware decisions based on where the application is being deployed and would break the separation of concerns between developers and operators. Think back to the metaphor of the shipping container. A shipping company should be free to use whichever train or warehouse they wish to move and store containers; the contents of a container should not be a factor when deciding what infrastructure to use. Another problem with **virtual machines is that they use a lot of CPU and memory**, and take a long time to boot. A virtual machine is still a machine. It is not a suitable unit for software delivery.

To sum up, to deploy software reliably and repeatably across computers, we need a box into which to put the application's code. **This box should contain the entire system** so that developers have a complete understanding of what they are shipping, **but should not include machine details** because that would be taking it too far. It should also not suffer from the performance cost of a virtual machine. Last but not least, this **box must have a standard interface** that stays the same regardless of what application is stored inside.

